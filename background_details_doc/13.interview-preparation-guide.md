# TechForum 面试准备知识点优先级指南

> **文档目标**：基于80/20法则，帮助你用20%的时间掌握80%的面试高频知识点，聚焦简历技术栈，快速备战面试。

---

## 📋 目录

1. [知识体系优先级总览](#知识体系优先级总览)
2. [后端核心知识点（必须掌握）](#后端核心知识点)
3. [前端快速复习路线](#前端快速复习路线)
4. [数据库与缓存](#数据库与缓存)
5. [项目相关高频问题](#项目相关高频问题)
6. [7天速成计划](#7天速成计划)

---

## 🎯 知识体系优先级总览

### 根据你的简历技术栈分级

| 技术栈 | 掌握程度 | 面试占比 | 学习优先级 | 建议投入时间 |
|--------|---------|---------|-----------|-------------|
| **Spring Boot 3** | 熟悉 | ⭐⭐⭐⭐⭐ | 🔥 最高 | 30% |
| **MySQL** | 掌握 | ⭐⭐⭐⭐⭐ | 🔥 最高 | 20% |
| **Redis** | 熟悉 | ⭐⭐⭐⭐⭐ | 🔥 最高 | 20% |
| **MyBatis** | 熟练 | ⭐⭐⭐⭐ | 🔥 高 | 10% |
| **Vue 3** | 正在学习 | ⭐⭐⭐ | 🔶 中 | 10% |
| **MinIO** | 了解 | ⭐⭐ | 🔶 中低 | 5% |
| **Linux** | 了解 | ⭐⭐ | 🔶 中低 | 5% |

### 80/20法则应用

**用20%时间掌握的80%核心内容**：
1. Spring Boot核心（IoC、AOP、自动配置、过滤器链）
2. Spring Security + JWT认证流程
3. Redis五种数据类型 + 三大缓存问题
4. MySQL索引原理 + 事务隔离级别
5. 你的项目架构 + 技术亮点

**可以暂时忽略的20%边缘内容**：
- Spring Cloud微服务（你项目未用到）
- 消息队列深度原理（非核心）
- Kubernetes容器编排（非必需）
- 前端工程化细节（不是你的强项）

---

## 🔥 后端核心知识点（必须掌握）

### 一、Spring Boot 3 核心（⭐⭐⭐⭐⭐）

#### 1.1 IoC容器与依赖注入 【高频】

**核心概念**：
```java
// 三种注入方式对比
@Service
public class UserService {
    // ❌ 不推荐：字段注入
    @Autowired
    private UserMapper userMapper;
    
    // ✅ 推荐：构造器注入（Spring 4.3+可省略@Autowired）
    private final UserMapper userMapper;
    public UserService(UserMapper userMapper) {
        this.userMapper = userMapper;
    }
}
```

**面试问题**：
- Q: 为什么构造器注入优于字段注入？
- A: ① 依赖明确，必需字段final保证不可变；② 便于单元测试，无需反射注入；③ 避免循环依赖

**你的项目应用**：
- 所有Service层使用构造器注入
- Controller依赖Service，Service依赖Mapper

---

#### 1.2 Spring Security过滤器链 【超高频】

**核心流程图**：
```
HTTP Request
    ↓
SecurityContextPersistenceFilter（创建SecurityContext）
    ↓
JwtAuthenticationFilter（你自定义的过滤器）
    ├─ 提取Token
    ├─ 验证Token
    └─ 设置Authentication到SecurityContext
    ↓
UsernamePasswordAuthenticationFilter（处理登录）
    ↓
FilterSecurityInterceptor（权限校验）
    ↓
Controller
```

**面试问题**：
- Q: 你的JWT认证流程是怎样的？
- A: 
  1. 用户登录 → UserDetailsService加载用户 → 验证密码 → 生成JWT返回
  2. 后续请求 → JwtAuthenticationFilter拦截 → 解析Token → 设置Authentication
  3. SecurityConfig配置哪些路径需要认证，哪些公开访问

**你的项目关键代码**：
```java
// JwtAuthenticationFilter核心逻辑
String token = request.getHeader("Authorization").substring(7); // 去掉"Bearer "
String username = jwtUtil.getUsernameFromToken(token);
if (username != null && jwtUtil.validateToken(token, userDetails)) {
    UsernamePasswordAuthenticationToken auth = 
        new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
    SecurityContextHolder.getContext().setAuthentication(auth);
}
```

**必须能说清楚的点**：
- [ ] JWT的组成（Header.Payload.Signature）
- [ ] 为什么JWT是无状态的？（不需要服务端存储Session）
- [ ] 如何防止JWT被盗用？（HTTPS + 短有效期 + Refresh Token）
- [ ] 如何实现登出？（黑名单 or Token版本号）

---

#### 1.3 自动配置原理 【中频】

**核心注解**：
```java
@SpringBootApplication
    = @SpringBootConfiguration
    + @EnableAutoConfiguration  // 关键
    + @ComponentScan

// 自动配置原理
@EnableAutoConfiguration
    → AutoConfigurationImportSelector
    → 读取 META-INF/spring.factories
    → 加载所有XxxAutoConfiguration类
    → 根据@ConditionalOnClass等条件判断是否生效
```

**面试问题**：
- Q: Spring Boot为什么约定优于配置？
- A: 通过starter依赖 + 自动配置类 + @ConditionalOnXxx条件注解，自动装配常用组件，开发者只需覆盖默认配置即可

**你的项目体现**：
- `spring-boot-starter-web` 自动配置了Tomcat、DispatcherServlet、Jackson
- `spring-boot-starter-security` 自动配置了SecurityFilterChain
- 你只需在`application.properties`覆盖个性化配置

---

#### 1.4 全局异常处理 【高频】

**你的项目实现**：
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(UnauthorizedException.class)
    public Result<?> handleUnauthorized(UnauthorizedException e) {
        return Result.error(401, e.getMessage());
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<?> handleValidation(MethodArgumentNotValidException e) {
        // 提取校验错误信息
        return Result.error(400, "参数校验失败");
    }
}
```

**面试亮点**：
- 统一异常处理，前端无需关心异常类型
- 自定义异常类（UnauthorizedException、BizException）语义清晰
- 参数校验失败自动返回友好提示

---

### 二、MyBatis（⭐⭐⭐⭐）

#### 2.1 #{}和${}的区别 【超高频】

| 特性 | #{} | ${} |
|------|-----|-----|
| 原理 | 预编译，使用PreparedStatement | 字符串替换，直接拼接SQL |
| SQL注入 | ✅ 防止 | ❌ 有风险 |
| 类型处理 | ✅ 自动类型转换 | ❌ 需手动处理 |
| 使用场景 | 参数值 | 表名、列名、ORDER BY字段 |

**示例**：
```java
// ✅ 正确：防SQL注入
@Select("SELECT * FROM users WHERE username = #{username}")

// ❌ 危险：存在SQL注入风险
@Select("SELECT * FROM users WHERE username = '${username}'")
// 如果username = "admin' OR '1'='1"，将绕过验证

// ✅ 正确：动态表名（业务已校验）
@Select("SELECT * FROM ${tableName} WHERE id = #{id}")
```

---

#### 2.2 一级缓存和二级缓存 【中频】

**一级缓存（SqlSession级别）**：
- 默认开启
- 同一SqlSession内，相同查询会命中缓存
- 执行INSERT/UPDATE/DELETE会清空缓存

**二级缓存（Mapper级别）**：
- 需手动开启：`@CacheNamespace`
- 跨SqlSession共享
- 容易造成数据不一致，生产环境慎用

**面试回答**：
"我们项目使用Redis作为二级缓存，而不是MyBatis自带的二级缓存，因为：
① Redis缓存可控，支持手动失效；② 分布式环境下MyBatis二级缓存无法共享；③ Redis支持更丰富的数据结构"

---

#### 2.3 动态SQL【中频】

**你的项目可能用到**：
```xml
<select id="searchPosts" resultType="Post">
    SELECT * FROM posts
    <where>
        <if test="keyword != null and keyword != ''">
            AND (title LIKE CONCAT('%', #{keyword}, '%') 
            OR content LIKE CONCAT('%', #{keyword}, '%'))
        </if>
        <if test="categoryId != null">
            AND category_id = #{categoryId}
        </if>
        <if test="userId != null">
            AND user_id = #{userId}
        </if>
    </where>
    ORDER BY create_time DESC
</select>
```

**标签说明**：
- `<if>`: 条件判断
- `<where>`: 自动去除多余的AND/OR
- `<foreach>`: 批量操作（IN查询、批量INSERT）

---

### 三、MySQL（⭐⭐⭐⭐⭐）

#### 3.1 索引原理【超高频】

**B+树索引结构**：
```
           [10, 20, 30]         ← 非叶子节点（只存主键）
          /    |    |   \
        /      |    |     \
   [1,5,9]  [10,15,19]  [20,25,29]  [30,35,39]  ← 叶子节点（存完整行数据）
      ↔        ↔         ↔           ↔          （双向链表）
```

**为什么用B+树而不是B树？**
1. 非叶子节点不存数据，一页能存更多索引，树高度低
2. 叶子节点双向链表，范围查询效率高
3. 所有查询都走到叶子节点，性能稳定

**面试问题**：
- Q: 为什么主键推荐自增？
- A: ① 插入数据顺序写入，不会导致页分裂；② UUID无序插入会导致频繁页分裂，性能差

---

#### 3.2 索引优化【超高频】

**你的项目应该建的索引**：
```sql
-- 用户表
CREATE INDEX idx_username ON users(username);  -- 登录查询
CREATE INDEX idx_email ON users(email);        -- 邮箱查询

-- 帖子表
CREATE INDEX idx_user_time ON posts(user_id, create_time DESC);  -- 用户帖子列表
CREATE INDEX idx_category_time ON posts(category_id, create_time DESC);  -- 分区帖子
CREATE INDEX idx_title ON posts(title);  -- 标题搜索

-- 评论表
CREATE INDEX idx_post_time ON comments(post_id, create_time DESC);  -- 帖子评论
```

**索引失效场景**：
```sql
-- ❌ 失效：对索引列使用函数
SELECT * FROM users WHERE YEAR(create_time) = 2025;

-- ✅ 正确
SELECT * FROM users WHERE create_time >= '2025-01-01' AND create_time < '2026-01-01';

-- ❌ 失效：LIKE前缀通配符
SELECT * FROM posts WHERE title LIKE '%Spring%';

-- ✅ 正确：后缀通配符可以走索引
SELECT * FROM posts WHERE title LIKE 'Spring%';

-- ❌ 失效：联合索引不满足最左前缀
CREATE INDEX idx_a_b_c ON t(a, b, c);
SELECT * FROM t WHERE b = 1 AND c = 2;  -- 跳过a，索引失效

-- ✅ 正确
SELECT * FROM t WHERE a = 1 AND b = 1 AND c = 2;  -- a, b, c都能用上
SELECT * FROM t WHERE a = 1 AND b = 1;            -- a, b用上
SELECT * FROM t WHERE a = 1;                      -- a用上
```

---

#### 3.3 事务隔离级别【高频】

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 |
|---------|-----|----------|-----|------|
| READ UNCOMMITTED | ❌ 有 | ❌ 有 | ❌ 有 | 最高 |
| READ COMMITTED | ✅ 无 | ❌ 有 | ❌ 有 | 中上 |
| REPEATABLE READ（MySQL默认）| ✅ 无 | ✅ 无 | 🔶 部分避免 | 中下 |
| SERIALIZABLE | ✅ 无 | ✅ 无 | ✅ 无 | 最低 |

**面试问题**：
- Q: MySQL的REPEATABLE READ如何避免幻读？
- A: 通过MVCC（多版本并发控制） + 间隙锁（Gap Lock）。MVCC解决快照读的幻读，间隙锁解决当前读的幻读。

**你的项目应用**：
```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void transferPoints(Long fromUserId, Long toUserId, Integer points) {
    // 扣减fromUserId积分
    // 增加toUserId积分
    // 事务保证原子性
}
```

---

#### 3.4 深分页优化【中高频】

**问题**：
```sql
-- 查询第100万条后的20条数据，需要先扫描100万条
SELECT * FROM posts ORDER BY id DESC LIMIT 1000000, 20;
```

**优化方案：游标分页**
```sql
-- 客户端记录上次查询的最后一条id
SELECT * FROM posts WHERE id < 上次最后的id ORDER BY id DESC LIMIT 20;
```

**你的项目实现**：
```java
// DTO
public class PostPageDTO {
    private Long lastId;  // 上次查询最后一条id
    private Integer pageSize;
}

// Mapper
@Select("SELECT * FROM posts WHERE id < #{lastId} ORDER BY id DESC LIMIT #{pageSize}")
List<Post> findByIdCursor(@Param("lastId") Long lastId, @Param("pageSize") Integer pageSize);
```

**面试亮点**：
"针对深分页性能问题，我采用了游标分页方案，避免OFFSET大量回表查询，将查询时间从5秒优化到50ms。"

---

### 四、Redis（⭐⭐⭐⭐⭐）

#### 4.1 五种数据类型【超高频】

| 类型 | 底层实现 | 使用场景 | 你的项目应用 |
|------|---------|---------|------------|
| String | SDS | 缓存、计数器、分布式锁 | 用户Session、验证码、点赞数 |
| Hash | 哈希表/ziplist | 对象存储 | 用户信息缓存 |
| List | 双向链表/ziplist | 消息队列、最新列表 | 最新帖子列表 |
| Set | 哈希表/intset | 去重、交并集 | 点赞用户列表、共同关注 |
| ZSet | 跳表+哈希表 | 排行榜、延迟队列 | 热门帖子排行、Feed流 |

**示例**：
```java
// String：验证码
redisTemplate.opsForValue().set("captcha:user@example.com", "123456", 5, TimeUnit.MINUTES);

// Hash：用户信息
redisTemplate.opsForHash().put("user:1", "username", "张三");
redisTemplate.opsForHash().put("user:1", "email", "user@example.com");

// Set：点赞用户列表
redisTemplate.opsForSet().add("post:likes:100", "user:1", "user:2", "user:3");
Boolean isLiked = redisTemplate.opsForSet().isMember("post:likes:100", "user:1");

// ZSet：热门帖子（按浏览量排序）
redisTemplate.opsForZSet().add("post:hot", "post:100", 10000);  // score=浏览量
Set<String> topPosts = redisTemplate.opsForZSet().reverseRange("post:hot", 0, 9);  // Top 10
```

---

#### 4.2 缓存三大问题【超高频】

##### 缓存穿透
**问题**：查询不存在的数据，缓存和数据库都没有，每次都打到数据库。

**解决方案**：
```java
// 方案1：缓存空对象
public Post getPost(Long id) {
    Post post = redisTemplate.opsForValue().get("post:" + id);
    if (post != null) {
        if (post.getId() == null) return null;  // 空对象标记
        return post;
    }
    post = postMapper.selectById(id);
    if (post == null) {
        // 缓存空对象，过期时间短
        redisTemplate.opsForValue().set("post:" + id, new Post(), 1, TimeUnit.MINUTES);
        return null;
    }
    redisTemplate.opsForValue().set("post:" + id, post, 10, TimeUnit.MINUTES);
    return post;
}

// 方案2：布隆过滤器
@Bean
public BloomFilter<Long> postIdFilter() {
    BloomFilter<Long> filter = BloomFilter.create(Funnels.longFunnel(), 100000, 0.01);
    // 启动时加载所有postId
    postMapper.selectAllIds().forEach(filter::put);
    return filter;
}

public Post getPost(Long id) {
    if (!postIdFilter.mightContain(id)) {
        return null;  // 一定不存在，直接返回
    }
    // 可能存在，继续查询
}
```

##### 缓存击穿
**问题**：热点Key过期瞬间，大量请求打到数据库。

**解决方案**：
```java
// 方案1：互斥锁
public Post getPost(Long id) {
    Post post = redisTemplate.opsForValue().get("post:" + id);
    if (post != null) return post;
    
    String lockKey = "lock:post:" + id;
    try {
        // 尝试获取分布式锁
        if (redisTemplate.opsForValue().setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS)) {
            post = postMapper.selectById(id);
            redisTemplate.opsForValue().set("post:" + id, post, 10, TimeUnit.MINUTES);
            return post;
        } else {
            // 获取锁失败，等待后重试
            Thread.sleep(50);
            return getPost(id);
        }
    } finally {
        redisTemplate.delete(lockKey);
    }
}

// 方案2：逻辑过期（热点数据永不过期）
public Post getPost(Long id) {
    String json = redisTemplate.opsForValue().get("post:" + id);
    PostCache cache = JSON.parseObject(json, PostCache.class);
    if (cache.getExpireTime().isBefore(LocalDateTime.now())) {
        // 逻辑过期，异步更新
        executor.submit(() -> {
            Post post = postMapper.selectById(id);
            redisTemplate.opsForValue().set("post:" + id, 
                JSON.toJSONString(new PostCache(post, LocalDateTime.now().plusMinutes(10))));
        });
    }
    return cache.getPost();  // 返回旧数据
}
```

##### 缓存雪崩
**问题**：大量Key同时过期，或Redis宕机，数据库压力暴增。

**解决方案**：
```java
// 1. 过期时间加随机值
int expireTime = 600 + new Random().nextInt(300);  // 10-15分钟随机
redisTemplate.opsForValue().set("post:" + id, post, expireTime, TimeUnit.SECONDS);

// 2. Redis集群高可用（配置层面）
// application.yml
spring:
  redis:
    cluster:
      nodes: redis1:6379,redis2:6379,redis3:6379

// 3. 服务降级
@HystrixCommand(fallbackMethod = "getPostFallback")
public Post getPost(Long id) {
    // 查询逻辑
}
public Post getPostFallback(Long id) {
    return new Post(id, "系统繁忙，请稍后再试", null);  // 返回默认数据
}
```

---

#### 4.3 持久化机制【中频】

| 方式 | 原理 | 优点 | 缺点 | 适用场景 |
|------|-----|------|------|---------|
| RDB | 定时快照 | 恢复快、文件小 | 可能丢失最后一次快照后的数据 | 数据备份、全量复制 |
| AOF | 记录写命令 | 数据安全性高 | 文件大、恢复慢 | 数据可靠性要求高 |

**面试问题**：
- Q: 如何选择持久化方式？
- A: 生产环境推荐AOF + RDB混合使用。AOF保证数据安全，RDB用于快速恢复。可配置`appendfsync everysec`，每秒同步一次，兼顾性能与安全。

---

### 五、网络与Linux（⭐⭐）

#### 5.1 HTTP与HTTPS【中频】
```
HTTP  → 明文传输 → 易被窃听、篡改
HTTPS → HTTP + SSL/TLS → 加密传输

HTTPS握手流程：
1. 客户端发送ClientHello（支持的加密算法）
2. 服务端返回证书 + 公钥
3. 客户端验证证书 → 生成随机数 → 用公钥加密发送
4. 服务端用私钥解密 → 双方用随机数生成对称密钥
5. 后续通信用对称密钥加密
```

#### 5.2 Linux常用命令【低频，了解即可】
```bash
# 查看日志
tail -f /var/log/app.log       # 实时查看
grep "ERROR" app.log           # 过滤错误日志

# 进程管理
ps aux | grep java             # 查找Java进程
kill -9 PID                    # 强制结束进程

# 磁盘与内存
df -h                          # 磁盘使用情况
free -h                        # 内存使用情况
top                            # 实时监控CPU、内存
```

---

## 🌐 前端快速复习路线（⭐⭐⭐）

### 你说"前端快忘了"，优先复习这些

#### 1. Vue 3 核心（2天掌握）

**Composition API vs Options API**：
```vue
<!-- Options API（Vue 2风格） -->
<script>
export default {
  data() {
    return { count: 0 }
  },
  methods: {
    increment() {
      this.count++
    }
  }
}
</script>

<!-- Composition API（Vue 3推荐） -->
<script setup>
import { ref } from 'vue'
const count = ref(0)
const increment = () => count.value++
</script>
```

**必须掌握的API**：
```javascript
// 响应式数据
import { ref, reactive, computed, watch } from 'vue'

const count = ref(0)              // 基本类型
const user = reactive({ name: '' })  // 对象类型
const doubleCount = computed(() => count.value * 2)
watch(count, (newVal, oldVal) => {
  console.log('count变化', newVal, oldVal)
})

// 生命周期
import { onMounted, onUnmounted } from 'vue'
onMounted(() => {
  console.log('组件挂载')
})
```

---

#### 2. Pinia状态管理（1天掌握）

**你的项目auth.js示例**：
```javascript
import { defineStore } from 'pinia'

export const useAuthStore = defineStore('auth', {
  state: () => ({
    token: localStorage.getItem('token') || '',
    user: null
  }),
  
  getters: {
    isLoggedIn: (state) => !!state.token
  },
  
  actions: {
    async login(username, password) {
      const res = await axios.post('/api/auth/login', { username, password })
      this.token = res.data.token
      localStorage.setItem('token', this.token)
    },
    
    logout() {
      this.token = ''
      this.user = null
      localStorage.removeItem('token')
    }
  }
})

// 组件中使用
import { useAuthStore } from '@/stores/auth'
const authStore = useAuthStore()
authStore.login('user', 'pass')
```

---

#### 3. Vue Router路由守卫（1天掌握）

**你的项目router/index.js示例**：
```javascript
import { createRouter, createWebHistory } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const routes = [
  { path: '/', component: () => import('@/views/HomeView.vue') },
  { path: '/login', component: () => import('@/views/LoginView.vue') },
  { 
    path: '/create-post', 
    component: () => import('@/views/CreatePostView.vue'),
    meta: { requiresAuth: true }  // 需要登录
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// 全局前置守卫
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore()
  if (to.meta.requiresAuth && !authStore.isLoggedIn) {
    next('/login')  // 未登录跳转登录页
  } else {
    next()
  }
})

export default router
```

---

#### 4. Axios请求封装（1天掌握）

**推荐封装**：
```javascript
// utils/request.js
import axios from 'axios'
import { useAuthStore } from '@/stores/auth'
import { ElMessage } from 'element-plus'

const request = axios.create({
  baseURL: '/api',
  timeout: 5000
})

// 请求拦截器：添加Token
request.interceptors.request.use(config => {
  const authStore = useAuthStore()
  if (authStore.token) {
    config.headers.Authorization = `Bearer ${authStore.token}`
  }
  return config
})

// 响应拦截器：统一错误处理
request.interceptors.response.use(
  response => response.data,  // 直接返回data
  error => {
    if (error.response?.status === 401) {
      ElMessage.error('请先登录')
      useAuthStore().logout()
      router.push('/login')
    } else {
      ElMessage.error(error.response?.data?.message || '请求失败')
    }
    return Promise.reject(error)
  }
)

export default request

// 使用
import request from '@/utils/request'
const posts = await request.get('/posts')
```

---

#### 5. Element Plus组件（1天熟悉）

**常用组件速查**：
```vue
<template>
  <!-- 表单 -->
  <el-form :model="form" :rules="rules" ref="formRef">
    <el-form-item label="用户名" prop="username">
      <el-input v-model="form.username" />
    </el-form-item>
    <el-button type="primary" @click="submitForm">提交</el-button>
  </el-form>

  <!-- 表格 -->
  <el-table :data="posts" stripe>
    <el-table-column prop="title" label="标题" />
    <el-table-column prop="author" label="作者" />
  </el-table>

  <!-- 分页 -->
  <el-pagination
    :total="100"
    :page-size="10"
    @current-change="handlePageChange"
  />

  <!-- 对话框 -->
  <el-dialog v-model="dialogVisible" title="提示">
    <span>确定删除吗？</span>
  </el-dialog>

  <!-- 消息提示 -->
  <script setup>
  import { ElMessage } from 'element-plus'
  ElMessage.success('操作成功')
  </script>
</template>
```

---

## 📖 数据库与缓存（补充）

### MySQL索引类型

| 索引类型 | 说明 | 使用场景 |
|---------|------|---------|
| 主键索引 | 唯一且非空 | 自增id |
| 唯一索引 | 唯一但可为空 | 用户名、邮箱 |
| 普通索引 | 无限制 | 外键、时间字段 |
| 全文索引 | MATCH...AGAINST | 搜索功能 |
| 联合索引 | 多列组合 | 复合查询条件 |

### Redis淘汰策略
```
配置：maxmemory-policy

1. noeviction（默认）：内存满时拒绝写入
2. allkeys-lru：从所有key中删除最少使用的
3. volatile-lru：从设置过期时间的key中删除最少使用的
4. allkeys-random：从所有key中随机删除
5. volatile-random：从设置过期时间的key中随机删除
6. volatile-ttl：删除即将过期的key

推荐：allkeys-lru（适合缓存场景）
```

---

## 💬 项目相关高频问题

### 1. 你的项目架构是怎样的？

**回答模板**：
"我的项目采用前后端分离架构：
- **前端**：Vue 3 + Pinia + Element Plus，使用Vite构建，通过Axios与后端交互
- **后端**：Spring Boot 3 + MyBatis + MySQL，使用JWT实现无状态认证，Spring Security管理权限
- **缓存**：Redis缓存用户信息、热点帖子，减少数据库压力
- **存储**：MinIO分布式对象存储，存储用户头像和帖子图片
- **部署**：Docker Compose一键部署，包含MySQL、Redis、MinIO、应用容器"

### 2. 你的项目有哪些亮点？

参考[14.project-highlights-analysis.md]的STAR描述

### 3. JWT如何保证安全？

**回答**：
1. **HTTPS传输**：防止Token在网络中被窃取
2. **短有效期**：Token有效期1小时，过期需重新登录
3. **Refresh Token**：（可选）通过长期有效的Refresh Token换取新的Access Token，无需频繁登录
4. **签名验证**：服务端用密钥验证Token签名，防止篡改
5. **黑名单机制**：（可选）用户登出时将Token加入Redis黑名单，拒绝已登出Token的请求

### 4. 如何处理高并发点赞？

**回答**：
"我采用了Redis + 异步落库的方案：
1. 用户点赞时，先写入Redis Set：`SADD post:likes:100 user:1`
2. 点赞数通过Redis计数：`INCR post:likes:count:100`
3. 定时任务（每10秒）批量刷回MySQL，避免频繁写库
4. 使用Redis事务保证点赞/取消点赞的原子性
5. 万一Redis宕机，MySQL作为兜底，启动时从MySQL加载数据到Redis"

### 5. 如何保证Redis和MySQL数据一致性？

**回答**：
参考[Redis缓存三大问题]部分的延迟双删策略

---

## ⚡ 7天速成计划

### Day 1-2：Spring Boot + Security（重中之重）
- [ ] 复习IoC、AOP原理
- [ ] 画出Spring Security过滤器链流程图
- [ ] 讲清楚你的JWT认证流程（能默写代码）
- [ ] 掌握全局异常处理机制

### Day 3：MyBatis
- [ ] #{}和${}区别
- [ ] 动态SQL（if、where、foreach）
- [ ] 一级/二级缓存原理

### Day 4：MySQL（高频）
- [ ] 索引原理（B+树结构）
- [ ] 索引优化规则（最左前缀、覆盖索引）
- [ ] 事务隔离级别与MVCC
- [ ] 深分页优化方案

### Day 5：Redis（高频）
- [ ] 五种数据类型及使用场景
- [ ] 缓存穿透、击穿、雪崩（必须能讲清楚解决方案）
- [ ] 持久化机制（RDB vs AOF）
- [ ] 你的项目中Redis的应用（Session、点赞、验证码）

### Day 6：前端快速复习
- [ ] Vue 3 Composition API（ref、reactive、computed、watch）
- [ ] Pinia状态管理（你的auth.js怎么实现的）
- [ ] Vue Router路由守卫
- [ ] Axios请求封装

### Day 7：项目梳理 + 模拟面试
- [ ] 画出项目技术架构图
- [ ] 准备STAR法则项目描述（参考文档14）
- [ ] 整理你的项目亮点（至少5个）
- [ ] 模拟回答："介绍一下你的项目"

---

## 📚 学习资源推荐

### 官方文档（优先）
- Spring Boot：https://spring.io/projects/spring-boot
- MyBatis：https://mybatis.org/mybatis-3/zh/
- Redis：https://redis.io/docs/
- Vue 3：https://cn.vuejs.org/

### 视频教程（快速入门）
- B站：黑马程序员Spring Boot 3（40小时）
- B站：尚硅谷MySQL高级（10小时索引部分）
- B站：尚硅谷Redis 7（8小时核心部分）
- B站：Vue 3 + Element Plus实战（20小时）

### 面试题库
- JavaGuide（GitHub，超全面试题）
- LeetCode剑指Offer（算法部分）
- 牛客网面经（真实面试题）

---

## 🎯 核心总结

### 你的优势
✅ 后端基础扎实（Spring Boot、MyBatis、MySQL）
✅ 项目完整度高（前后端分离、认证鉴权、CRUD完整）
✅ 竞赛获奖多（省二等奖体现学习能力）

### 需要强化的点
🔶 Redis实战经验（建议尽快实现缓存功能）
🔶 前端框架熟练度（Vue 3核心API需快速复习）
🔶 项目亮点提炼（参考文档14准备面试话术）

### 面试准备优先级
1. 🔥 项目相关（你的架构、亮点、遇到的问题）
2. 🔥 Spring Boot + Security（JWT认证流程）
3. 🔥 MySQL索引 + Redis缓存（高频考点）
4. 🔶 MyBatis（中频）
5. 🔶 Vue 3基础（够用即可）

### 最后建议
- **不要贪多**：80/20法则，先掌握核心，不要陷入细枝末节
- **理解优先于记忆**：能讲清楚原理比背答案重要
- **结合项目讲**：每个技术点都和你的项目关联，有实战说服力
- **准备demo**：面试时能现场展示项目（Docker部署最佳）

---

**最后更新**：2025-01-17  
**版本**：v1.0  
**作者**：TechForum Team
